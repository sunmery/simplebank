# This workflow will build a golang project
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-go

name: Deploy to production
run-name: ${{ github.actor }} is learning GitHub Actions

on:
  push:
    branches: [ "main", "beta" ]

jobs:

  frontend-build-dist:
    # 将作业配置为在最新版本的Ubuntu Linux运行程序上运行,
    # 注意此处不是Docker Hub中的ubuntu:latest, 而是Github中自己的虚拟主机。
    runs-on: ubuntu-latest
    # 默认值配置
    defaults:
      # 运行在jobs中
      run:
        # 默认的shell解释器
        shell: bash
        # 默认的工作目录, 即使用该值作为job运行的根目录
        working-directory: frontend

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - uses: pnpm/action-setup@v2
        with:
          version: latest

      - # 设置Node版本, 最低为20
        name: Setup node version
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          cache-dependency-path: '**/pnpm-lock.yaml'

      # - name: Test frontend
      #   # 自动下载pnpm
      #   # 注意：pnpm 缓存支持需要 pnpm 版本 >= 6.10.0
      #   run: |
      #     npm install -g pnpm@latest
      #     #pnpm test

      - name: Build frontend
        # 自动下载pnpm
        # 注意：pnpm 缓存支持需要 pnpm 版本 >= 6.10.0
        run: |
          # npm install -g pnpm@latest
          #pnpm test
          # 只安装锁文件的依赖. pnpm 实现的等效npm ci, 即只根据pnpm-lock.yaml的依赖进行安装
          pnpm install --frozen-lockfile
          pnpm build

  frontend-build-image:
    needs: frontend-build-dist
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: frontend
    steps:
      - # 检出仓库中的代码，确保脚本可以访问仓库中的所有文件
        name: Checkout repository
        uses: actions/checkout@v4

      - # 设置 QEMU 仿真器。允许你在 x86 架构的主机上构建和测试其他架构的 Docker 镜像
        # https://github.com/docker/setup-qemu-action
        name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - # Buildx 是 Docker 的一个插件，支持多平台构建
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - # 登录到容器注册表
        name: Login Cloud Registry
        run: echo ${{ secrets.REGISTRY_PASSWORD }} | docker login ${{ secrets.REGISTRY }} --username ${{ secrets.REGISTRY_USERNAME }} --password-stdin

      - # 构建, 标记, 推送镜像到容器注册表
        name: Build tag and push image to Cloud Registry
        env:
          VERSION: v2.0.0
          NODE_VERSION: node:22-alpine3.19
          PACK_VERSION: latest
          HTTP_PORT: 30003
          HTTPS_PORT: 30004

        run: |
          docker buildx build . \
            --progress=plain \
            -t actions/frontend \
            --build-arg NODE_VERSION=$NODE_VERSION \
            --build-arg PACK_VERSION=$PACK_VERSION \
            --build-arg HTTP_PORT=$HTTP_PORT \
            --build-arg HTTPS_PORT=$HTTPS_PORT \
            --load

          docker tag actions/frontend ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_FRONTEND_REPOSITORY }}:latest
          # docker tag actions/frontend ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_FRONTEND_REPOSITORY }}:$VERSION
          # docker tag actions/frontend ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_FRONTEND_REPOSITORY }}:$GITHUB_SHA

          docker push ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_FRONTEND_REPOSITORY }}:latest
          # docker push ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_FRONTEND_REPOSITORY }}:$VERSION
          # docker push ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_FRONTEND_REPOSITORY }}:$GITHUB_SHA

  frontend-deploy:
    needs: frontend-build-image
    runs-on: ubuntu-latest
    env:
      FRONTEND_NAMESPACE: bank
      # 1024以下端口需要容器的特权(即root)权限才能执行, 运行特权权限容器有安全风险
      # 建议使用1024以上端口, 再通过Ingress/Gateway或者LoadBalancer来映射为80/443端口
      HTTP_PORT: 3000
      HTTPS_PORT: 4430
    defaults:
      run:
        shell: bash
        working-directory: frontend/deploy/application/overlays/production
    steps:
      - # 检出仓库中的代码，确保脚本可以访问仓库中的所有文件
        name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Kustomize
        run: |
          curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
          chmod u+x ./kustomize
          ./kustomize version

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl{,.sha256}"
          echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
          chmod +x ./kubectl

      - name: Connect Kubernetes Cluster
        run: |
          mkdir -pv ~/.kube/
          echo "${{secrets.KUBE_CONF}}" > ~/.kube/config
          ./kubectl get all -n ${FRONTEND_NAMESPACE}

      - name: Deploy
        run: |
          # 创建命名空间并切换到该命名空间
          if ./kubectl get ns ${FRONTEND_NAMESPACE}; then
            echo "namespaces ${FRONTEND_NAMESPACE} already exists, skip create"
          else
            ./kubectl create ns ${FRONTEND_NAMESPACE}
          fi
          ./kubectl config set-context --current --namespace $FRONTEND_NAMESPACE
          
          # 将nginx的配置文件上传到configmap, 然后Pod引用
          # 将SSL文件(crt/key)上传到secret, 然后Pod引用
          echo "${{secrets.SSL_CERTIFICATE}}" > /tmp/nginx.crt
          echo "${{secrets.SSL_PRIVATE_KEY}}" > /tmp/nginx.key
          cat <<EOF > /tmp/nginx.conf
          server {
              listen ${HTTP_PORT};
              server_name ${{secrets.DOMAIN}}; # server_name
              # return 301 https://${{secrets.DOMAIN}}; # website
          }

          server {
              server_name ${{secrets.DOMAIN}} www.${{secrets.DOMAIN}};  # 服务器名称

              # UDP listener for QUIC+HTTP/3
              # http/3
              listen ${HTTPS_PORT} quic reuseport;

              # http/2 and http/1.1
              listen ${HTTPS_PORT} ssl;
              http2 on;

              # 以下为各种 HTTP 安全相关头部的设置
              add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";
              add_header X-XSS-Protection "1; mode=block" always;
              add_header X-Frame-Options SAMEORIGIN always;
              add_header X-Content-Type-Options nosniff;
              add_header X-Frame-Options "DENY";
              add_header Alt-Svc 'h3=":${HTTPS_PORT}"; ma=86400, h3-29=":${HTTPS_PORT}"; ma=86400';

              # SSL/TLS 相关配置
              ssl_protocols TLSv1.3 TLSv1.2;  # 设置支持的 SSL 协议版本
              # ssl_ciphers ...;  # 设置 SSL 密码套件
              ssl_prefer_server_ciphers on;  # 优先使用服务器的密码套件
              ssl_ecdh_curve X25519:P-256:P-384;  # 设置 ECDH 曲线
              ssl_early_data on;  # 启用 TLS 1.3 的 0-RTT 特性
              ssl_stapling on;  # 启用 OCSP Stapling
              ssl_stapling_verify on;  # 启用 OCSP Stapling 的验证

              # SSL 证书路径配置
              ssl_certificate     /etc/nginx/ssl/nginx.crt;  # SSL 证书路径
              ssl_certificate_key /etc/nginx/ssl/nginx.key;  # SSL 证书密钥路径

              location / {
                  root   /etc/nginx/html;  # 设置根目录路径
                  index  index.html index.htm default.html default.htm;  # 设置默认index首页文件
              }
          }
          EOF
          ./kubectl delete cm nginx-conf || true
          ./kubectl create cm nginx-conf --from-file=/tmp/nginx.conf

          ./kubectl delete cm nginx-conf || true
          ./kubectl create cm nginx-conf --from-file=/tmp/nginx.conf


          ./kubectl delete secret nginx-ssl || true
          ./kubectl create secret generic nginx-ssl \
            --from-file /tmp/nginx.crt \
            --from-file /tmp/nginx.key
          
          ./kustomize edit set image example=${{ secrets.REGISTRY }}/${{ secrets.REGISTER_FRONTEND_REPOSITORY }}:${GITHUB_SHA}
          ./kustomize build . | kubectl apply -f -
          
          ./kubectl rollout status deploy
          ./kubectl get po -owide
          ./kubectl get svc

  backend-test:
    runs-on: ubuntu-latest
    env:
      GIN_MODE: release
    defaults:
      run:
        shell: bash
        working-directory: backend
    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres:17-alpine
        # Provide the password for postgres
        env:
          # 数据库用户名
          POSTGRES_USER: postgres
          # 数据库用户密码
          POSTGRES_PASSWORD: postgres
          # 此可选环境变量可用于为首次启动映像时创建的默认数据库定义不同的名称。如果未指定，则将使用 POSTGRES_USER 的值。
          POSTGRES_DB: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        # Maps tcp port 5432 on service container to the host
        ports:
          - '5432:5432'
    steps:
      - # 检出仓库中的代码，确保脚本可以访问仓库中的所有文件
        name: Checkout repository
        uses: actions/checkout@v4

      -
        # 设置Go版本和缓存机制
        # https://github.com/actions/setup-go#caching-dependency-files-and-build-outputs
        name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'
          # 检查是否最新版
          check-latest: true
          # 检查项目中所有的go.sum, 对于单体和多服务的应用都生效
          cache-dependency-path: '**/go.sum'

      - name: Install migrate
        run: |
          curl -L https://github.com/golang-migrate/migrate/releases/download/v4.18.1/migrate.linux-amd64.tar.gz | tar xvz
          sudo mv migrate /usr/bin/
          which migrate

      - name: Run database migrate
        run: |
          DB_SOURCE="postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable"
          make migrate-up

      - name: Test
        run: |
          make test

  backend-build:
    needs: backend-test
    name: Build image
    runs-on: ubuntu-latest
    env:
      GOOS: linux
      GOARCH: amd64
      VERSION: v2.0.0
      GOIMAGE: golang:1.23.1-alpine3.20
      CGOENABLED: 0
    defaults:
      run:
        shell: bash
        working-directory: backend
    steps:
      - # 检出仓库中的代码，确保脚本可以访问仓库中的所有文件
        name: Checkout repository
        uses: actions/checkout@v4

      - # 设置 QEMU 仿真器。允许你在 x86 架构的主机上构建和测试其他架构的 Docker 镜像
        # https://github.com/docker/setup-qemu-action
        name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - # Buildx 是 Docker 的一个插件，支持多平台构建
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - # 缓存依赖项
        name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-modules-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-go-modules-

      - # 登录到容器注册表
        name: Login Cloud Registry
        run: echo ${{ secrets.REGISTRY_PASSWORD }} | docker login ${{ secrets.REGISTRY }} --username ${{ secrets.REGISTRY_USERNAME }} --password-stdin

      - # 构建, 标记, 推送镜像到容器注册表
        name: Build tag and push image to Cloud Registry
        env:
          VERSION: v2.0.0
          PORT: 8080
          CGO_ENABLED: 0
          GO_IMAGE: golang:1.23.1-alpine3.20

        run: |
          docker buildx build . \
            --progress=plain \
            -t actions/backend \
            --build-arg GOIMAGE=$GOIMAGE \
            --build-arg CGOENABLED=$CGOENABLED \
            --build-arg VERSION=$VERSION \
            --build-arg PORT=$PORT \
            --build-arg GOOS=$GOOS \
            --build-arg GOARCH=$GOARCH \
            --platform $GOOS/$GOARCH \
            --load
          
          docker tag actions/backend ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_REPOSITORY }}:$VERSION
          # docker tag actions/backend ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_REPOSITORY }}:latest
          # docker tag actions/backend ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_REPOSITORY }}:$GITHUB_SHA
          
          docker push ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_REPOSITORY }}:latest
          # docker push ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_REPOSITORY }}:$VERSION
          # docker push ${{ secrets.REGISTRY }}/${{ secrets.REGISTER_REPOSITORY }}:$GITHUB_SHA

  backend-deploy:
    needs: backend-build
    env:
      DEPLOYMENT_NAME: simple-bank-api
      BACKEND_NAMESPACE: bank
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: backend/deploy/application/overlays/production
    steps:
      - # 检出仓库中的代码，确保脚本可以访问仓库中的所有文件
        name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Kustomize
        run: |
          curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
          chmod u+x ./kustomize
          ./kustomize version

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl{,.sha256}"
          echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
          chmod +x ./kubectl

      - name: Connect Kubernetes Cluster
        run: |
          mkdir -pv ~/.kube/
          echo "${{secrets.KUBE_CONF}}" > ~/.kube/config

      # Deploy the Docker image to the TKE cluster
      - name: Deploy
        run: |
          if ./kubectl get ns ${BACKEND_NAMESPACE}; then
            echo "namespaces ${BACKEND_NAMESPACE} already exists, skip create"
          else
            ./kubectl create ns ${BACKEND_NAMESPACE}
          fi
          
          ./kubectl config set-context --current --namespace $BACKEND_NAMESPACE
          
          ./kubectl delete secret db-source-secret || true 
          ./kubectl create secret generic db-source-secret --from-literal='DB_SOURCE=${{ secrets.DB_SOURCE }}'
          
          ./kustomize edit set image example=${{ secrets.REGISTRY }}/${{ secrets.REGISTER_REPOSITORY }}:$GITHUB_SHA
          ./kustomize build . | kubectl apply -f -
          
          ./kubectl rollout status deploy
          ./kubectl get po -owide
          ./kubectl get svc
